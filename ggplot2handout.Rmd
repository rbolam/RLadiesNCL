---
title: "Data visualisation handout"
output:
  word_document: default
  html_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
```

# Slides

## Data Visualisation in R

In this session you will learn how to make graphs in R. We will mainly use the ggplot2 package. R and ggplot2 are completely free, and make it easy to produce publication-ready plots quickly. 

By the end of the session you will be able to:

- Make different types of plots such as scatter plots, bar plots, histograms, box plots, area plots and density plot
- Easily make subplots of your data with faceting 
- Arrange plots in a grid
- Customise your plots - this is very useful for your final thesis, as you can easily build and change one template for all of your plots


## How we will work today


You will get a handout with all of the code we will use today. We will slowly start to build up the code, to make plots more customised. 

Run the code that is provided here, and try to make sure you understand what it does. There are also exercises where you need to change the code a bit. There is an answer sheet you can get once you are finished with everything.

If you get stuck with anything, please ask!

## Some basics of ggplot2

In your code, you need to specify a few things:

- the type of plot you want (called geom)
- how you display your data - for example the colour or size of dots, bars etc (with scale functions)
- how the overall plot looks (the theme)
- whether you want subplots of your data (called facets)

## Loading the package

```{r}
library(ggplot2)
str(iris) # we will use this inbuilt dataframe today

```

## Scatter plot

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point()

```

## Scales

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(colour=Species))
```

## Adjusting the scales

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(colour=Species)) + 
  scale_colour_brewer(palette="Greens")
```

## Themes

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(colour=Species)) + 
  scale_colour_brewer(palette="Greens") + theme_classic()
```

## Facets

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + 
  scale_colour_brewer(palette="Greens") + theme_classic() + facet_wrap(~Species)
```

## Useful links/resources


There is lots of useful info online on making plots with ggplot2, but this book is a great starting point:

Wickham, H. and Grolemund, G. (2016) R for data science. 

Free at http://r4ds.had.co.nz/ It was written by the guy who wrote the package ggplot2. 

Another useful book is this one: http://www.cookbook-r.com/Graphs/

On the grid package: http://ww2.amstat.org/publications/jse/v18n3/zhou.pdf


# Practical


Please note: the code you need to type is in the grey boxes. Somestimes comments are added following a #, to further explain some of the code.

## Loading ggplot2 into R

To start using ggplot2, first open RStudio, then install and load the package with the following code:

```{r, eval=FALSE}
install.packages("ggplot2")
library(ggplot2)
```

There is a lot of information about ggplot2 online, so if you get stuck you can try to google what you are trying to do. There is also a useful data visualisation cheat sheet - once you have used ggplot2 a bit, it will become more and more useful: https://www.rstudio.com/resources/cheatsheets/


## A very basic plot in ggplot2

We will use data that are in-built in R for this session, using the iris, diamonds and mtcars datasets. 

```{r}
str(iris) 
# Have a look at the iris dataset, so you know which variables there are and what types of variables they are
```

We will start with some short code that will produce a plot in ggplot2. The basic pattern of the ggplot2 function first names the dataset, then the x and y variables. With ```geom_```, you add the type of plot you want:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() 
# this will now produce a basic scatterplot of sepal lengths against petal lengths 
```

The plot will be empty if you don't specify the type of plot you want:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, Petal.Length))
```


## Customising a plot

### Axis labels

We can now start to customise the plot, so it looks exactly how we want it to look. We can change the axis labels by adding ```xlab``` or ```ylab```:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) +  geom_point() + xlab("Sepal length") + ylab("Petal length")
```


#### Exercise: Change the variable on the x-axis from Sepal.Length to Petal.Width. Make sure to change the axis labels too.



### Size and transparency

If you have a lot of data points, it can be difficult to see all of the points as they might overlap. You can change the size or transparency of the points so they are easier to see:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(size=3) 
# changing the size to 3 will make the dots bigger


ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(alpha=0.3) 
# Changing alpha to 0.3 will make the dots more transparent. Some of the dots appear darker because there is actually more than one data point in the same place


ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(size=7, alpha=0.5) 
# You can change the look of a plot by changing both size and transparency
```

#### Exercise: Change size, transparency, or both so that the dots can be seen better.



### Colour

In ggplot2, we can change things like the colour, size or shape of our data points, either by changing all of them, or by making them look different depending on another variable. We can change the colour of all dots by defining the colour within ```geom_point()```:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(color="blue") 
```

We could also change the colour of each dot, depending on the type of species it is. To do so we need to add ```aes``` within ```geom_point()```:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(color=Species))
# Note that there is a legend in your plot now!
```

The plot will be made with default colours, different for each species. To customise the colours, we need to adjust the scales:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(colour=Species)) + scale_colour_brewer(palette="Greens", name="Iris species")
```

The scale function is used to customise how our data look, in this case we want to customise the colours in the plot. Whatever we specified in ```geom_point``` as an aesthetic, in this case colour, we need to put into the scale function: ```scale_colour```. Here we will use colours from the RColorBrewer package, so we add ```brewer``` at the end. Inside the bracket we specify which colours we want to use, and ```name``` specifies the title of the legend. If you want to see all of the colour options in RColorBrewer, run the following code:

```{r, eval=FALSE}
library(RColorBrewer)

display.brewer.all()
```

#### Exercise: Change the colours of the plot, by picking a colour option from RColorBrewer.


In the previous example we used a categorical variable (Species) to set the colours. We can also use continuous variables for colours - the colours will change along a gradient:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(colour=Petal.Width)) + scale_colour_gradient(low="yellow", high="blue", name="Petal width")
```

In this example, we did not use RColorBrewer, but in-built R colour names. You can find a (very long) list of colour names in R here: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf


#### Exercise: Change the colours in the plot, using the in-built R colour names.


#### Exercise: We can also change the size of the dot according to another variable. Instead of changing the colour, can you change the size of the dot according to the Petal.Width variable? What is the difference in the code between making all dots bigger, and making them bigger depending on another variable?



### Shapes


We can change the dots to different symbols too, for example open circles or triangles. Each symbol corresponds to a number, which we add in ```geom_point()```:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(shape=1)

ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(shape=17)
```

#### Exercise: Can you change the symbol to a square, and then to a cross? Use the ggplot2 cheat sheet (link at the start of this document) to find which number corresponds to which.


We could also change the dots to symbols depending on another variable - similar to changing the colour depending on the species, as in the colour example. This can be useful if we need to use black-and-white plots:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(shape=Species))
```

#### Exercise: What would a scale function look like to change the symbols of each species? Change the symbols for each species with the function. If you get stuck, use your ggplot2 cheat sheet.


### Zooming in on a plot

Sometimes we might not want to display the whole range of the x- and y-axes, or we want to start them from 0. We can specify the exact axes ranges we want to display using ```coord_cartesian()```:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + coord_cartesian(xlim=c(0,10), ylim=c(0,10))
```

### Adding a line from your model

If you are presenting data to which you fitted a model, you can add the line by using ```geom_smooth()```:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + geom_smooth(method=glm) 
# Here we fit a generalised linear model to the data. 95% confidence intervals are displayed automatically

ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + geom_smooth(method=glm, se=FALSE)
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + geom_smooth(method=glm, level=0.99)
# We can also remove the confidence intervals, or change them to 99% confidence intervals
```


## Customising the overall look of the plot


We can change the overall look of the plot by changing the theme. The theme will not affect how your plotted data look, just the setup of the plot:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + theme_classic()
```

For a list of themes see http://ggplot2.tidyverse.org/reference/ggtheme.html. We will look at how we can change these settings manually later.


#### Exercise: Try out three of the themes and see how the plots change.


## Using ggplot2 for different types of plots 

Your plots will look different depending on the variables you are displaying - whether there are one, two or more to display, and whether they are categorical, ordinal or continuous. We will now use the dataset diamonds which is part of the ggplot2 package:

```{r}
str(diamonds)
```

### One continuous variable


If you have one continuous variable, you will likely use a histogram:

```{r}
ggplot(data=diamonds, aes(x=carat))+geom_histogram()
```

You can adjust the number of bars by setting the binwidth:

```{r}
ggplot(data=diamonds, aes(x=carat))+geom_histogram(bins=5)

ggplot(data=diamonds, aes(x=carat))+geom_histogram(bins=500)
```

#### Exercise: Change the number of bins until they show the pattern in the data clearly.


You could also use a density plot to display one continuous variable. Note what happens to the y-axis:

```{r}
ggplot(data=diamonds, aes(x=carat)) + geom_density()


ggplot(data=diamonds, aes(x=carat)) + geom_density(aes(fill=cut)) 
# note that for density plots, we need to use fill not colour - colour would just change the colour of the outline
```

The area under the curve in a density plot sums to one, so the y-axis does not show a count, but a value between 0 and 1.

#### Exercise: In our last plot, the different densities were overlapping. How can you change the plot so we can see all densities at once?


Another option would be an area plot:

```{r}
ggplot(data=diamonds, aes(x=carat))+geom_area(stat="bin", aes(fill=color))


ggplot(data=diamonds, aes(x=carat))+geom_area(stat="bin", aes(fill=color), position="fill")
```

If you change ```position="stack"``` (which is the default for ```geom_area()```) to ```position="fill"```, the plot effectively shows a percentage on the y-axis. 


#### Exercise: Can you change the colours in the last plot?


### One categorical variable

If you have one categorical variable, you will need a bar graph. This will show a count of each of the categories:

```{r}
ggplot(data=diamonds, aes(x=cut))+geom_bar()
```

### Two continuous variables


If you have two continuous variables, you normally represent them with dots - see the examples from the iris dataset we used at the start.


### One continuous and one categorical variable

If you have a categorical and a continuous variable, you would normally put the categorical variable on your x-axis and the continuous variable on your y-axis. These are often displayed as box plots (they show the four quartiles in the data, and outliers as dots):

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot()
```

There are also other options in ggplot2 such as violin plots:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_violin(scale="area")
```

Or you could present your data as a bar plot. The default ```geom_bar()``` option just uses a categorical variable for x. To show a categorical x and a continuous y variable, we need to add ```stat="identity"``` here:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_bar(stat="identity") 
```

You can change the colour of the bar by another categorical variable:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_bar(aes(fill=cut), stat="identity")
```

#### Exercise: Using your ggplot2 cheat sheet, can you find a way to stack the bars next to each other instead?


You can also flip the x- and y-axis:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_bar(stat="identity") + coord_flip()
```


## Adding error bars

To add error bars to a ggplot2 plot, we need to calculate the means and standard errors first. We will create a new dataset with the aggregate function. If you are unsure what your new data look like, use the ```str()``` or ```summary()``` functions:

```{r}
summaryd<-aggregate(price ~ color, diamonds, FUN = function(x) c(mean = mean(x), sd = sd(x),  n = length(x))) 
```

We are creating a new dataframe called summaryd. In it, we are summarising the continuous variable price by the color groups. We will get a mean with ```mean```, standard deviation with ```sd``` and number of observations with ```length``` of price within each color group.

```{r}
summaryd <- do.call(data.frame, summaryd) 
# this turns it into a dataframe

summaryd$se <- summaryd$price.sd / sqrt(summaryd$price.n)
```

We add a new variable called se which is the standard deviation divided by the sample size - the standard error. Now we can plot the error bars:


```{r}
ggplot(data=summaryd, aes(x=color, y=price.mean)) + geom_bar(stat="identity", position="dodge") +  geom_errorbar(aes(ymin=price.mean-se, ymax=price.mean+se), width=0.2, position="dodge")
```


## Time series

To plot time series, we might have to change the format of our dataset. Have a look at the inbuilt dataset uspop:

```{r}
str(uspop)

uspop
```

It is in a different format to the data we used so far. First we need to ensure that year and the values are both variables:

```{r}
uspop2 <- data.frame(Year = c(time(uspop)), Value = c(uspop))

# this turns the time values of uspop into the variable Year, and the other values into variable Value, in the new dataset uspop2
```

Now we can use the data to plot the population over time:

```{r}
ggplot(data=uspop2, aes(x=Year, y=Value)) + geom_line()
```

We can also add points for each year in addition to the line:

```{r}
ggplot(data=uspop2, aes(x=Year, y=Value)) + geom_line() + geom_point()
```

#### Exercise: Change the colour and the thickness of the line and points, so they are easier to see. 


## Facets

One very useful feature of ggplot2 is the use of facets, where we split the data into subgroups, depending on a categorical variable, and make individual plots for each group. We can do this very easily by just adding a little bit of code. We will use our boxplot from earlier again to see how the facetting changes the plot:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot()

ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot() + facet_wrap(~cut)
```

```facet_wrap()``` can be arranged by specifying the number of rows or columns with ```nrow``` or ```ncol```:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot() + facet_wrap(~cut, nrow=3)
```

#### Exercise: Change how the plots are arranged, by putting all of them in one row, and then in one column. Which one is more useful?


```facet_grid()``` on the other hand always arranges the plots in a grid:

```{r}
ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot() + facet_grid(~cut)

ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot() + facet_grid(clarity~cut)
```

## A completely custom ggplot2 theme


Now you know how to make plots in ggplot2 with the default settings, you can start to make customised plots by changing the theme. This will not change how the data are displayed, but how the plot itself looks. It is useful if you want all plots in your thesis to have the same look.


Here is an example of a customised plot, with annotation for the code:

```{r}
ggplot(data=iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + facet_wrap(~Species)+
scale_colour_gradient(low="green", high="blue", name="Petal width")+ 
# this is similar to a plot we made earlier

theme(text= element_text(size=14), 
# this changes the font size to 14

axis.text = element_text(angle=30, size = rel(0.8)),         
# this changes the angle of the axis labels (often useful for bar plots), and makes the font slightly smaller than the rest of the plot

axis.ticks = element_line(colour = "black"),

plot.background = element_rect(fill="white"), 
#this is the colour behind the plot

panel.background = element_rect(fill = "mintcream"), 
# this is the colour inside the plots

panel.border = element_rect(fill = NA, colour = "black"),

panel.grid.major = element_line(colour = "lightskyblue3", size = .1),

panel.grid.minor = element_line(colour = "mintcream"), 

# the minor grid lines - same colour as each panel

strip.background = element_rect(fill = "lightskyblue2", colour = "black", size = 0.5))#this refers to the box with the heading above each facet
```

#### Exercise: Create a custom theme that you could use for your PhD thesis. You can start with the code above, and change more bits of the theme (use ?theme() to find all the things you can change). 

#### Exercise: Use the inbuilt dataset called mtcars to make some plots. Make at least one scatterplot, one boxplot, and one facetted plot. Then use your theme that you created for the iris scatterplot for the new plots.  

Tip: If a variable is numeric, but you could display it as a factor, you could set up your code like this: ````ggplot(data=mtcars, aes(x=factor(variable1), y=variable2)) + geom_boxplot()````



## Saving a plot

Your plots will be saved in the folder that you set as your working directory. This line of code will save the last ggplot you made to a pdf:

```{r, eval=FALSE}
ggsave("plot.pdf")
```

Or you can save it as a jpg:

```{r, eval=FALSE}
ggsave("plot.jpg")
```

You can specify the size by adding dpi. You can also specify the exact width and height (in inches) which is useful for publications:

```{r, eval=FALSE}
ggsave("plot.pdf", dpi=300, width=5, height=5)
```



## The Grid package: Introduction


The grid package is useful for producing plots at specified locations of the plotting region or for producing customised multiple plots.


Grid graphics a is a low-level system for plotting within R. By "low-level", we mean that grid graphics functions are typically used to modify very specific elements of a plot, rather than being functions to use for a one-line plotting call.


For example, if you want to quickly plot a scatterplot of data, you should use ggplot2, but if you want to create a plot with an inset plot with tilted axis labels, then you may need to go to grid graphics.


The ggplot2 package works well with the Grid package and also some other graphics packages you might use in the future such as the lattice package. 


### Grobs


Grobs are graphical objects that you can make and change with grid graphics functions. 

For example, you may create a circle grob or points grobs. Once you have created one or more of these grobs, you can add them to or take them away from larger grid graphics objects, including ggplot objects.


Possible grobs that can be created using functions in the grid package include circles, rectangles, points, lines, polygons, curves, axes, rasters, segments, and plot frames.


Functions that create grobs typically include parameters to specify the location where the grobs should be placed. For example, the pointsGrob function includes x and y parameters, while the segmentsGrob includes parameters for the starting and ending location of each segment (x0, x1, y0, y1).

The grob family of functions also includes a parameter called gp for setting graphical parameters like color, fill, line type, line width, etc., for grob objects. The input to this function must be a gpar object, which can be created using the gpar function. For example, to create a grey circle grob, you could do:

```{r}
library(grid)

my_circle<-circleGrob(x=0.5,y=0.5,r=0.5,gp=gpar(col= "gray ",lty=3))
```

Aesthetics that you can set by specifying a gpar object for the gp parameter of a grob include color (col), fill (fill), transparency (alpha), line type (lty), line width (lwd), line end and join styles (lineend and linejoin, respectively), and font elements (fontsize, fontface, fontfamily). 

Once you have created a grob object, you can use the grid.draw function to plot it: 

```{r}
grid.draw(my_circle)
```

You can edit a grob too if you assign the grob a name e.g.
```{r}
my_circle<-circleGrob(name="my_circle", x=0.5,y=0.5,r=0.5, gp=gpar(col= "gray ",lty=3))

grid.draw(my_circle)

grid.edit("my_circle", gp = gpar(col = "red", lty = 1))
```

You can also add grobs to ggplots e.g

```{r}
wc_plot <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + 

geom_point()

grid.draw(wc_plot)

grid.draw(my_circle)
```

At the moment this isn't very useful but will be when we introduce viewports and coordinate systems. 

#### Exercise: Try creating grobs of different shapes and sizes. Try making a stick person out of different grobs (Hint: use grid.draw one after another to draw all of the grobs or look up how to use gTree). 


### Viewports 


The most useful thing about grid graphics is having the ability to move in and out of working spaces around the full graph area e.g. creating a map of the states of the US with a small pie chart added at the centroid of each state showing the distribution of population in that state by education level.


The smaller working spaces within the larger plot are called viewports.  Viewports are the plotting windows that you can move into and out of to customize plots using grid graphics.


To start with you can make a new viewport:

```{r}
grid.draw(rectGrob())                              #1

sample_vp <- viewport(x = 0.5, y = 0.5,            #2

                      width = 0.5, height = 0.5,   #3

                      just = c("left", "bottom"))  #4 

pushViewport(sample_vp)                            #5

grid.draw(roundrectGrob())                         #6

grid.draw(my_circle)                               #7          

popViewport()                                      #8

```

1. Draws a rectangular grob


2. Sets up the dimensions for the viewport (x & y are locations) 


3. Width and height are based on default units (1=full width/height of one side) 


4. Justification of viewport in relation to the location (this specifies the viewport should have it's location at its bottom left corner


5. Navigates into the viewport 


6. In the viewport it creates a rectangular grob with rounded corners 


7. Also draws the circle you created before 


8. Navigates out of the viewport 


#### Exercise:  Try changing the location, dimensions and justification of the viewport. Also try using different grobs within the viewport. 


You can also have more than one viewport, although you can only operate one viewport at a time. Once you are in that viewport, you can write grobs within the viewport. If you want to place the next grob in a different viewport, you will need to navigate out of that viewport before you can do so.

```{r}
grid.draw(rectGrob())  

sample_vp <- viewport(x = 0.5, y = 0.5,  

                      width = 0.5, height = 0.5, 

                      just = c("left", "bottom")) 

pushViewport(sample_vp) 

grid.draw(roundrectGrob()) 

grid.draw(my_circle) 

popViewport() 

sample_vp2 <- viewport(x = 0.1, y = 0.1,  

                      width = 0.25, height = 0.25, 

                      just = c("left", "bottom"))  

pushViewport(sample_vp2) 

grid.draw(roundrectGrob()) 

grid.draw(my_circle) 

popViewport()

```

You can also nest viewports inside each other. In this case a new viewport is defined relative to the current viewport not the overall plot. 


```{r}
grid.draw(rectGrob())

sample_vp_1 <- viewport(x = 0.5, y = 0.5, 

                      width = 0.5, height = 0.5,

                      just = c("left", "bottom"))

sample_vp_2 <- viewport(x = 0.1, y = 0.1, 

                      width = 0.4, height = 0.4,

                      just = c("left", "bottom"))

pushViewport(sample_vp_1)

grid.draw(roundrectGrob(gp = gpar(col = "red")))

pushViewport(sample_vp_2)

grid.draw(roundrectGrob())

grid.draw(my_circle)

popViewport(2)           #navigate back to the main plotting area 
```


#### Exercise:  Using ggplots you have already created try adding in grobs to highlight a certain part of the plot and also add in an insert of another plot you have created. 


## The grid.arrange function


Sometimes we might have multiple plots that we need to save within one file. We can use the grid.arrange function from the gridExtra package for this. We can use this with ggplot2. We need to create our plots first, but this time we need to name them:

```{r}
library(gridExtra)

plot1<-ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot()

plot2<-ggplot(data=diamonds, aes(x=cut, y=price)) + geom_boxplot() 
# note that the plots will not appear in the plots window, unless you call plot1 or plot2
```

Now we have many options how to arrange the plots:

```{r}
grid.arrange(plot1, plot2, ncol=1)

grid.arrange(plot1, plot2, nrow=1)
```

We can also make one plot bigger than the other. We need to set up a layout, in which 1 refers to the first plot, and 2 refers to the second plot:

```{r}
grid.arrange(plot1, plot2, layout_matrix = matrix(c(1, 1, 2), ncol=3))
# This will put plot1 into the width of 2 columns, and adds plot2 in the 3rd column
```

#### If we have more than one row and more than one column, the layout will first list the left-hand column from top to bottom, then the right-hand column. 

We can use it to make a custom layout with gaps:

```{r}
grid.arrange(plot1, plot2, layout_matrix = matrix(c(1, 2, 1, NA), ncol = 2)) # the layout first list the top left, then bottom left, top right, then bottom right
```

To save grid.arrange plots, we need to save them differently to the ggplot2 plots:

```{r, eval=FALSE}
pdf("plot1.pdf")

plot1<-ggplot(data=diamonds, aes(x=color, y=price)) + geom_boxplot()

plot2<-ggplot(data=diamonds, aes(x=cut, y=price)) + geom_boxplot()

grid.arrange(plot1, plot2, ncol=1)

dev.off()
```

#### Exercise: Make two custom arranged plots with grid.arrange using the mtcars dataset. Use a gap in one of them, then save them into your working directory.



## Additional exercises


There are a lot of other packages in R now that add more functionality to ggplot2. Have a look at the ggplot2 extensions website (http://www.ggplot2-exts.org/gallery/) and see whether any of the packages might be useful for your own work. There are packages with more themes (for example ggthemes), a package for making animated graphs (gganimate), packages for plotting graph structures (for example ggraph) and so on.


If you find a package you would like to try, install and load it. Read the help files to find out what functions you can run in the package. 


Otherwise use the package ggridge:

```{r, eval=FALSE}
install.packages("ggridges")
```
```{r}
library(ggridges)
```

Have a look at the introduction here: https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html

Make some ridgeline plots for the iris dataset - use petal width on the x-axis, and species on the y-axis. Can you make plots that overlap, and some that don't overlap?


You can also use the ggthemes package to try different themes to the ones that are inbuilt with ggplot2. Install and load the package, then use three different themes from the package. 